function createLandscape(e) {
    // Variables for the scene, renderer, camera, and mesh
    var t, n, a, i,
        // Get the canvas element for rendering
        r = document.querySelector(".landscape"),
        // Get the current window dimensions
        o = window.innerWidth,
        s = window.innerHeight,
        // Object to track mouse/touch movement
        l = {x: 0, y: 0, xDamped: 0, yDamped: 0},
        // Check if the device supports touch (mobile)
        m = void 0 !== window.orientation;

    // Function to create the sky and sun
    function u() {
        // Create a sky object
        (u = new THREE.Sky).scale.setScalar(450000); // Scale the sky

        // Set sky material properties for atmospheric effects
        u.material.uniforms.turbidity.value = 1; // Clarity of the atmosphere
        u.material.uniforms.rayleigh.value = 0.01; // Scattering of light
        u.material.uniforms.luminance.value = 1; // Brightness of the sky
        u.material.uniforms.mieCoefficient.value = 0.0003; // Mie scattering coefficient
        u.material.uniforms.mieDirectionalG.value = 0.99995; // Directional scattering

        // Add the sky to the scene
        t.add(u);

        // Create a sun sphere (invisible, used for lighting calculations)
        sunSphere = new THREE.Mesh(
            new THREE.SphereBufferGeometry(20000, 16, 8), // Geometry of the sun
            new THREE.MeshBasicMaterial({color: 16777215}) // White color
        );
        sunSphere.visible = false; // Sun sphere is not visible
        t.add(sunSphere);

        // Position the sun in the sky
        var e = -0.03 * Math.PI, // Vertical angle
            n = 2 * Math.PI * -0.25; // Horizontal angle
        sunSphere.position.x = 400000 * Math.cos(n);
        sunSphere.position.y = 400000 * Math.sin(n) * Math.sin(e);
        sunSphere.position.z = 400000 * Math.sin(n) * Math.cos(e);

        // Update the sky's sun position uniform
        u.material.uniforms.sunPosition.value.copy(sunSphere.position);
    }

    // Function to handle window resizing
    function d() {
        o = window.innerWidth; // Update width
        s = window.innerHeight; // Update height
        a.aspect = o / s; // Update camera aspect ratio
        a.updateProjectionMatrix(); // Update projection matrix
        n.setSize(o, s); // Update renderer size
    }

    // Function to handle mouse or touch movement
    function c(e) {
        var t, n;
        e.preventDefault(); // Prevent default browser behavior
        if ("mousemove" == e.type) {
            // Mouse movement
            t = e.clientX;
            n = e.clientY;
        } else {
            // Touch movement
            t = e.changedTouches[0].clientX;
            n = e.changedTouches[0].clientY;
        }
        l.x = t; // Update mouse/touch x position
        l.y = n; // Update mouse/touch y position
    }

    // Animation loop
    function p() {
        requestAnimationFrame(p); // Recursively call the animation loop

        // Smoothly interpolate (damp) the input positions
        l.xDamped = f(l.xDamped, l.x, 0.1); // Damped x position
        l.yDamped = f(l.yDamped, l.y, 0.1); // Damped y position

        // Update time for animations
        var m = 0.001 * performance.now(); // Time in seconds
        i.material.uniforms.time.value = m; // Pass time to shader uniforms

        // Update distortions and height based on input
        i.material.uniforms.distortCenter.value = 0.1 * Math.sin(m); // Center distortion
        i.material.uniforms.maxHeight.value = (function(e) {
            var r = 0, o = 20; // Min and max height
            return o + (e - r) / (s - r) * (5 - o); // Map yDamped to height range
        })(l.yDamped);

        // Render the scene
        n.render(t, a);
    }

    // Linear interpolation helper function (used for damping)
    function f(e, t, n) {
        return (1 - n) * e + n * t; // Interpolate between e and t with factor n
    }

    // Initialization function
    !function() {
        // Initialize the scene, camera, and renderer
        (function() {
            t = new THREE.Scene(); // Create a new scene

            // Set the background color and fog
            var e = new THREE.Color(0); // Black background
            t.background = e;
            t.fog = new THREE.Fog(e, 10, 400); // Fog starts at 10, ends at 400

            // Create the sky and sun
            u();

            // Create the perspective camera
            (a = new THREE.PerspectiveCamera(60, o / s, 0.1, 10000)).position.y = 8;
            a.position.z = 4;

            // Add ambient lighting
            ambientLight = new THREE.AmbientLight(16777215, 1); // White light
            t.add(ambientLight);

            // Create the WebGL renderer
            (n = new THREE.WebGLRenderer({
                canvas: r, // Use the provided canvas
                antialias: true // Enable antialiasing
            })).setPixelRatio(devicePixelRatio); // Set pixel ratio for high-DPI displays
            n.setSize(o, s); // Set the renderer size
        })();

        // Create the plane geometry for the landscape
        l = new THREE.PlaneBufferGeometry(100, 400, 400, 400); // Plane size and resolution

        // Define shader uniforms
        f = {
            time: {type: "f", value: 0}, // Time for animations
            distortCenter: {type: "f", value: 0.1}, // Center distortion
            roadWidth: {type: "f", value: 0.5}, // Width of the road
            pallete: {type: "t", value: null}, // Color palette texture
            speed: {type: "f", value: 1}, // Animation speed
            maxHeight: {type: "f", value: 10}, // Maximum height of the landscape
            color: new THREE.Color(1, 1, 1) // Default color (white)
        };

        // Create the shader material
        h = new THREE.ShaderMaterial({
            uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib.basic.uniforms, f]),
            vertexShader: document.getElementById("custom-vertex").textContent, // Vertex shader
            fragmentShader: document.getElementById("custom-fragment").textContent, // Fragment shader
            wireframe: false, // Disable wireframe
            fog: true // Enable fog
        });

        // Create the landscape mesh
        (i = new THREE.Mesh(l, h)).position.z = -180; // Position the plane
        i.rotation.x = -Math.PI / 2; // Rotate to lie flat
        t.add(i); // Add the plane to the scene

        // Load the palette image texture
        new THREE.TextureLoader().load(e.palleteImage, function(e) {
            i.material.uniforms.pallete.value = e; // Set the palette texture
            i.material.needsUpdate = true; // Mark material for update
        });

        // Start the animation loop
        p();

        // Add event listeners for input and resizing
        m ? window.addEventListener("touchmove", c, {passive: false}) : window.addEventListener("mousemove", c);
        window.addEventListener("resize", d);

        // Trigger the resize handler to initialize sizes
        d();
    }();
}

// Call the function to create the landscape
createLandscape({palleteImage: pallete});
